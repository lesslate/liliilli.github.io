---
layout: post
title: "OPGS16 개발일지. 과한 욕심은 금물이라고."
tags: 
date: 2018-07-20 +0900
categories: OPGS16
comments: false
---
<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

OPGS16 에 직접 관련된 얘기는 아니지만,.. 그래도 리팩터링 겸.

OPGS16 에서 스프라이트를 묘화하는 데 적극적으로 `OpenGL` 의 `glsl` 쉐이더를 사용하고 있다. 또한 2D 렌더링 컴포넌트에 자기가 원하는 커스텀 쉐이더를 갈아끼워 넣을 수도 있으며 `glsl` 의 `uniform` 변수를 설정하는 것도 가능하다. (다만 한 오브젝트 당 하나의 유니폼 쉐이더 컨테이너가 생기기 때문에 성능은 떨어진다.)

`uniform variable` 은 여러가지 타입을 지원한다. 일단 `float` 이나 `int` 부터 시작해서 `matrix` 그리고 텍스쳐와 배열 등등... 커스텀 쉐이더를 사용해서 제대로 렌더링을 하려면 `GetUniformLocation` 과 `glUniform4fv` 등등과 같은 함수를 사용해 쉐이더 프로그램에 변수 값을 전달줘야 한다. 여기까지가 `OPGS16` 아래에 있는 로우레벨 이야기다.

실제 스크립트 상에서 쉐이더를 사용해서 렌더링 컴포넌트에 여러가지 조작을 할 때는 직접 `gl` 함수를 호출하지 않고, 유니폼 변수들과 쉐이더 정보를 담고 있는 랩퍼 클래스가 직접 따라오기 때문에 이를 조작해서 값 조절을 할 수 있다. 문제는 이전까지의 함수 시그니쳐가 개판이라서 전혀 유저 친화적이지 않다는 것이었다.

![img_refc1]({{ "/assets/201807/img20_refc1.PNG" | absolute_url }})

`OPGS16` 을 개발할 초창기에는 템플릿 함수를 사용해서 아무렇게나 넣어도 타입을 다 인식하게 해서 유연성을 극대화한 API 을 제공해주자 라고 생각을 했기 때문에 저런 꼴이 난 것 같다. 막상 실제로 구현해보니 API 을 만든 나 조차도 가슴편히 쓸 수가 없었고 인텔리센스는 무용지물이었다.

그리고 `glsl` 의 유니폼 배열 변수는 원소마다 ID 을 가지고 있어서, 해당 원소의 ID 에 대해 포인터 배열 형식으로 값을 넘겨줄 수 있는데 위 템플릿 버전은 그렇게 구현하고자 하면 여러가지 트릭을 써야해서 안된다.

게다가 이번에 직접 샘플 게임을 만들게 되면서 리팩터링을 지금 하지 않으면 안되겠다고 직감, 템플릿 함수를 그대로 놔두고 새롭고 더 안정된 버전을 만들었다.

![img_refc2]({{ "/assets/201807/img20_refc2.PNG" | absolute_url }})

각기 다른 이름을 사용해서 유니폼 값을 갱신할 수 있도록 했다. 억지로 템플릿을 쓰는 것 보다 더 깔끔하고 유저 친화적이라고 생각한다.

(아님 뭐... 별 수 없지 씁)