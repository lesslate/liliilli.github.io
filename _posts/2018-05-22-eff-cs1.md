---
layout: post
title: 'Effective C# 노트 정리 (1)'
tags: 'C#'
categories:
  - 'C#'
comments: false
date: 2018-05-22 00:55:13
---
　
<!-- more -->

### Item 1. 지역변수를 선언할 때는 `var` 을 사용하는 것이 낫다.

* C# 3.0 부터 C++ 의 `auto` 와 같이 `var` 이라는 타입 연역을 지원하고 있다. C# 에서 특정 변수를 `var` 로 지정하면 오른쪽 표현식의 최종 타입을 왼쪽 변수의 타입으로 추론한다.

* 정확한 반환 타입을 알지 못한 채 올바르지 않은 타입을 명시적으로 지정하면 득보다 실이 많다. 타입 안정성이 향상될 것이라고 생각하지만 타입 이름은 어디까지나 타입 이름일 뿐이다.

* 변수의 타입과 같은 지엽적인 부분보다 변수의 의미 파악에 집중할 수 있다. 대신에 변수의 이름 및 메소드는 보다 의미 전달적이고 명확해야 한다.

* 내장된 숫자 타입과 함께 `var` 을 사용할 경우에는 항상 주의해야 한다. 경우에 따라 자동으로 형변환을 할 수 있기 때문이다.

* LINQ 을 사용할 경우에는 `var` 을 사용해서 성능 저하를 막을 수 있다.

* 확장 메서드는 `virtual` 로 선언될 수 없으며 `static` 이어야 한다. 따라서 확장 메서드는 컴파일 타임에 준해서 확장 메서드를 수행한다. 따라서 컴파일 타임에 타입을 결정할 때, 모호함을 불러 일으킬 수 있는 지 알아봐야 한다.

### Item 2. `const` 보다는 `readonly` 가 좋다.

* C# 은 컴파일 타임 상수와 런타임 상수 두 가지의 상수를 가진다. 전자는 `const` 이고 후자는 `readonly` 이다. 컴파일 상수는 더 빠르지만 IL 생성 시 값이 그대로 복사된다. 런타임 상수는 대신 상수의 참조 코드가 따라온다.

* `const` 는 기본 타입, `enum`, `string`, `null` 에 대해서만 정의 가능하다. 또한 생성자에서 초기화가 불가능하다. 메소드 내부에서 선언이 가능하다.
  * 일종의 `constexpr` 같은 느낌으로 보면 될 것 같다.


* `readonly` 는 모든 타입으로 생성이 가능하며 생성자에서 초기화가 가능하다. 메소드 내부에서 선언이 불가능하다. 다만 `const` 보다 유연하며 동일 클래스의 인스턴스라고 하더라도 각각 가지는 상수 값이 다를 수 있다.

* `const` 는 IL 에서 값을 복사하기 때문에 갱신 후 해당 값을 사용하는 다른 어셈블리와 다시 리빌드해야만 한다. `readonly` 는 참조 코드를 생성하기 때문에 그럴 필요가 없다.

* 되도록이면 `readonly` 을 쓰되 `const` 가 필요하다면 [https://github.com/dotnet/BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet) 에서 성능 향상 폭을 본 뒤 알맞게 사용하도록 한다.

* 선택적 매개변수 (optional parameter) 의 기본 값은 컴파일타임 상수의 형태로 저장되기 때문에 주의를 요한다. 혹은 선택적 매개변수를 아예 쓰지 않는 방법도 있다.

### Item 3. 캐스트보다는 `is`, `as` 가 좋다.

* C# 에서 형변환을 수행하는 두 가지 방법 중 하나는 `as` 을 사용한 런타임 형변환이고 나머지 하나는 `(Type)` 을 사용한 컴파일 & 런타임 형변환이다.

* 형변환을 수행하는 경우에는 `(Type)` 보다 `as` 와 `is` 을 적절히 사용하는 것이 좋다. 안전할 뿐만 아니라 런타임에 더 효율적으로 동작한다.

* 다만 `as` `is` 는 다형성 규칙을 준수하고, 임의로 작성한 형변환 오버로딩 함수를 무시한다. `(Type)` 은 형변환 오버로딩 메소드를 범위 안에 두지만 거동이 약간 까다롭다.

* `as` 는 런타임에 객체의 타입이 변환하려는 타입과 정확히 일치하거나, 런타임의 객체의 최종 타입이 다형성을 준수할 경우에만 성공적으로 수행이 된다. 실패할 경우에는 `null` 을 왼쪽 값에 반환한다. 다만 이 과정에서 새로운 객체가 생성되는 경우는 예외를 제외하고는 없다.
  * 박싱된 값 타입의 객체를 `as` 을 사용해서 다른 형으로 변환시에는 새로운 객체가 생성이 된다. 왜냐면 값 타입은 복사를 하지 않으면 안되기 때문이다.


* `(Type)` 은 컴파일 타임에 형변환 하고자 하는 객체의 컴파일 시 타입에 대해 형변환 가능한 오버로딩 함수가 있는가를 확인하고, 없을 경우 런타임에 `as` 와 같은 방식으로 형변환을 하고자 한다. 이 방식은 피타입의 구현부에 따라 다른 행동을 할 수 있기 때문에 취약성이 높아진다.

* 박싱된 값 타입, 혹은 일반 값 타입에 대해서도 `as` 을 쓸 수 있다. `int?` 와 같은 `nullable` 타입으로 값을 바꾼 후, 이에 대해 `null checking` 을 수행한다.

``` csharp
object o = Factory.GetValue();
var i = o as int?;
if (i != null)
  Console.WriteLine(i.Value);
```

* `foreach` 루프는 제네릭 타입이 아닌 `IEnumerable` 인터페이스를 사용한다. 즉, `IEnumerable` 에서 가져온 `IEnumerator` 의 `Current` 프로퍼티의 타입은 `System.Object` 이다. 이 때 `foreach` 는 `(Type)` 을 사용해서 형변환을 한다고 볼 수 있다.
  * `foreach` 는 내부에서 컬렉션 내부의 객체가 런타임에 어떤 타입인지, 형변환 가능한지 등을 확인하지 않는다.


* `is` 는 다형성을 준수하기 때문에 자식 클래스에 대해서 부모 클래스로 `is` 를 해도 `true` 을 반환한다.

* `GetType()` 은 좀 더 엄격하게 런타임에 객체의 타입을 정확하게 가져온다.

### Item 4. C# 6.0 부터 `string.Format()` 을 보간 문자열로 대체하라.

* 문자열 보간, `$"Hello {Object.World}"` 는 고전 문자열 포매팅 방식에 비해 장점이 많다. 컴파일러 입장에서 정적 타입 검사를 수행할 수 있기 때문에 실수를 방지할 수 있다.

* 기존 `string.Format()` 은 보간 문자열과는 다르게 포맷 문자열과 인자 리스트를 분리해서 전달한다. 또 보간 문자열과는 달리 컴파일 타임에 문자열과 인자의 개수가 일치하는 가를 검사하지 않는다. 다르면 예외가 발생한다.

* 보간 문자열은 문법 설탕으로 실제 컴파일러에서는 `param` 을 사용하여 `object` 배열을 전달하는 기존 포매팅 함수를 호출하도록 코드를 생성한다.

* `.Format()` 혹은 보간 문자열에 값 형식을 넣을 때, boxing 이 생기기 때문에 명시적으로 `.ToString()` 을 사용하면 성능 이점이 생긴다. 그리고 보간 문자열 사용 시, 대체 문자열에 일종의 포맷을 적용해서 사용하는 것도 가능하다.

``` csharp
Console.WriteLine($"The value of pi is {Math.PI.ToString("F2")}");
```

혹은 이렇게도 가능하다.

``` csharp
Console.WriteLine($"The value of pi is {Math.PI:F2}");
```

* 보간 문자열의 대체 문자열 안에서 논리 삼중 연산자 `?:` 을 사용할 수 도 있는데 이때는 표현식에 소괄호 `()`을 써야 컴파일 오류가 일어나지 않는다. 그리고 null propagation operator `??` 도 사용이 가능하다. 

* 보간 문자열은 가독성을 높일 수 있는 동시에 복잡하게 쓰면 가독성을 낮출 수도 있으니 주의해야 한다.

### Item 5. 문화권 별로 다른 문자열을 생성하려면 `FormattableString` 을 사용하라.

* `System.FormattableString` 은 C# 6.0 부터 추가된 글로벌라이제이션 대응 문자열 타입이다. 

* 보간 문자열을 사용할 때 명시적으로 `FormattableString` 타입으로 받거나 특정 행동에 주의하면서 `var` 로 객체 타입을 받는 방법이 존재한다.
  * 컴파일 코드 상에서, 메소드의 `string` 으로 받는 패러미터에 해당 객체를 넣으면 컴파일러는 타입을 `string` 으로 인식한다.
  * 반환 객체 오른쪽에 `.` 을 직접 사용해서는 안된다.


* Unity 는 해당 타입 없이 별도의 로컬라이제이션을 활용하고 있는 것 같다. [Link](https://unity3d.com/kr/learn/tutorials/topics/scripting/localized-text-component)
